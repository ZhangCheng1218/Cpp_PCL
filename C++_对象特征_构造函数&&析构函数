-------------------------------------构造函数和析构函数-------------------------------------
对象的初始化和清理时非常重要的安全问题
  一个对象或者变量没有初始状态，对其使用后果是未知
  同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

C++利用构造函数和析构函数解决上述问题，这俩函数将会被编译器自动调用，完成对象初始化和清理工作。
对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供。
编译器提供的构造函数和析构函数是空实现。

  构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。
  析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。


构造函数语法： 类名(){}
  1.构造函数，没有返回值也不写void
  2.函数名称与类名相同
  3.构造函数可以有参数，因此可以发生重载
  4.程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次

析构函数语法： ~类名(){}
  1.析构函数，没有返回值也不写void
  2.函数名称与类名相同，在名称前加上符号~
  3.析构函数不可以有参数，因此不可以发生重载
  4.程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次


class Person
{
public:

	//构造函数
	Person() 
	{
		cout << "Person的构造函数" << endl;
	}
	//析构函数
	~Person() 
	{
		cout << "Person的析构函数" << endl;	
	}
};

---------------------------------------------------------构造函数的分类和调用---------------------------------------
两种分类方式：
      按参数分为：有参构造和无参构造
      按类型分为：普通构造和拷贝构造
三种调用方式：
      括号法
      显示法
      隐式转换法
void test01() 
{
	//1、括号法
	Person p1;//默认构造函数调用
	Person p2(10);//有参构造函数;
	Person p3(p2);//拷贝构造函数
	//注意事项：
	//	调用默认构造函数的时候，不要加()
	//	因为	Person p1();	这种，编译器会认为是一个函数的声明，不会认为在创建对象

	//2、显示法
	Person p1;
	Person p2 = Person(10);//有参构造 
							//等号右边的 Person(10);是匿名对象，特点：当前行执行结束后，系统会立即回收掉匿名对象；
	Person p3 = Person(p2);//拷贝构造，不要利用拷贝构造函数来初始化匿名对象
						   //编译器会认为Person(p3);等价于Person p3; 认为是对象声明；
	//3、隐式转换法
	Person p4 = 10;			//相当于Person(p4)=Person(10);
	Person p5 = p4;			//拷贝构造
}

---------------------------------------------------------拷贝构造函数调用时机---------------------------------------
1.使用一个已经创建完毕的对象来初始化一个新对象
2.值传递的方式给函数参数传值
3.以值方式返回局部对象

//1.使用一个已经创建完毕的对象来初始化一个新对象
 void test01() 
{
	 Person p1(10);
	 Person p2(p1);
}
//2.值传递的方式给函数参数传值
 void dowork(Person p)//值传递，拷贝一个临时的副本出来
 {

 }

 void test02() 
 {
	 Person p;//-》默认构造
	 dowork(p);//-》实参传给形参时候调用拷贝构造函数
 }
//3.以值方式返回局部对象
 Person dowork3() 
 {
	 Person p1;//按照p1拷贝一个临时的对象
	 return p1;
 }
 void test03() 
 {
	 Person p = dowork3();
 }

---------------------------------------------------------构造函数调用规则---------------------------
创建一个类
默认情况下，C++编译器至少给一个类添加三个函数
1.默认构造函数（无参，函数体为空）
2.默认析构函数（无参，函数体为空）
3.默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：
	如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造
	如果用户定义拷贝构造函数，C++不会再提供其他构造函数

---------------------------------------------------------深拷贝和浅拷贝---------------------------
浅拷贝：简单的赋值拷贝操作；
深拷贝：在堆区重新申请空间，进行拷贝操作；

浅拷贝带来的问题：堆区的内存重复释放；要利用深拷贝解决；
#include<iostream>

using namespace std;

class Person
{
public:
	int m_age;
	int* m_hight;
public:
	Person()
	{
		cout << "Person()的默认构造函数" << endl;
	}
	Person(int age,int hight)
	{
		cout << "Person()的有参构造函数" << endl;
		m_age = age;
		m_hight = new int(hight);
	}

	Person(const Person& p)
	{
		cout << "Person()的拷贝构造函数" << endl;
		m_age = p.m_age;
		//如果不利用深拷贝在堆区创建内存，会导致浅拷贝带来的重复释放堆区问题；
		m_hight = new int(*p.m_hight);
	}
	~Person()
	{
		cout << "Person()的析构函数" << endl;
		if (m_hight!=NULL)
		{
			delete m_hight;
			m_hight = NULL;
		}
		
	}

};

void test01()
{
	Person p1(18,180);
	Person p2(p1);
	cout << "p1年龄身高" << p1.m_age <<"、" << *p1.m_hight << endl;
 	cout << "p2年龄身高" << p2.m_age << "、" <<* p2.m_hight << endl;
}




int main()
{
	test01();

	return 0;
}


如果属性在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题；
