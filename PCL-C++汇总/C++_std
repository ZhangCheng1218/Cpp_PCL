-------------------------------------------std::map-------------------------------------类似字典
Map是STL的一个关联容器，它提供一对一的数据处理能力（第一个称为关键字，每个关键字只能在map中出现一次，第二个称为该关键字的值）。
begin();----------------------返回指向map头部的迭代器
clear();----------------------删除所有元素
count();----------------------返回指定元素出现的次数
empty();----------------------如果map为空则返回true
end();------------------------返回指向map末尾的迭代器
equal_range();----------------返回特殊条目的迭代器对
erase();----------------------删除一个元素
find()------------------------查找一个元素
get_allocator();--------------返回map的配置器
insert();---------------------插入元素
key_comp();-------------------返回比较元素key的函数
lower_bound();----------------返回键值>=给定元素的第一个位置
max_size();-------------------返回可以容纳的最大元素个数
rbegin();---------------------返回一个指向map尾部的逆向迭代器
rend();-----------------------返回一个指向map头部的逆向迭代器
size();-----------------------返回map中元素个数
swap();-----------------------交换俩map
upper_bound();----------------返回键值>给定元素的第一个位置
value_comp();-----------------返回比较元素value的函数
-------------------------------------------std::unique_ptr-------------------------------------智能指针
C++ 11提供的用于防止内存泄漏的智能指针中的一种实现，独享被管理员对象指针所有权的智能指针。unique_ptr对象包装一个原始指针，并负责其生命周期。
当该对象被销毁时，会在其析构函数中删除关联的原始指针。
unique_ptr具有->和*运算符重载符，可以像普通指针一样使用



#include <iostream>
#include <memory>

struct Task {
    int mId;
    Task(int id ) :mId(id) {
        std::cout << "Task::Constructor" << std::endl;
    }
    ~Task() {
        std::cout << "Task::Destructor" << std::endl;
    }
};

int main()
{
    // 通过原始指针创建 unique_ptr 实例
    std::unique_ptr<Task> taskPtr(new Task(23));

    //通过 unique_ptr 访问其成员
    int id = taskPtr->mId;
    std::cout << id << std::endl;

    return 0;
}




