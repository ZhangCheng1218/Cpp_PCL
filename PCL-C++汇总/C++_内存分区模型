C++程序执行时，将内存大方向划分为4个区域
--------------------程序运行前-----------------------
1、代码区
存放函数体的二进制代码，由操作系统进行管理；
存放CPU执行的机器指令
代码区是共享的，只读的
2、全局区
存放全局变量和静态变量（static）以及常量（字符串常量和其他常量（const修饰））；
该区域数据在程序结束后由造作系统释放

->字符串常量-------------------在全局区
->const修饰全局变量------------在全局区
->const修饰局部变量------------不在全局区中
--------------------程序运行后------------------------
3、栈区
由编译器自动分配释放，存放函数的参数值，局部变量等；
注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放
4、堆区
由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收；
在C++中，主要用new 在堆区开辟内存

new操作符
 类型 *p=new 类型（数据）,new 返回的类型的指针；
 堆区数据由程序员管理开辟、释放，如果想要释放，用关键词delete
 
-----------------------------------引用----------------------------------- 
给变量起别名；
数据类型 &别名=原名；
int a=10;
int &b=a;//起别名
注意：
1、引用必须初始化；
2、引用一旦初始化后，就不可以更改了；
---------------------------------引用做函数参数----------------------------
1、值传递
void Swap(int a,int b)
{
}
2、地址传递
void Swap(int *a,int *b)
{
}
3、引用传递
形参中的int&a,int&b相当于实参的别名
void Swap(int& a,int& b)
{
}
-----------------------------引用做函数返回值----------------------
1、不要返回局部变量的引用；
    局部变量在栈区
2、函数的调用可以作为左值；
  如果函数做左值，必须返回引用；
int& test()
{
static int a=10;
return a;
}
int main()
{
int &ref=test();
cout<<"ref="<<ref<<endl;//输出10
test()=100;
cout<<"ref="<<ref<<endl;//输出100，ref是a的别名
return 0;
}
------------------------------------引用的本质--------------------------
本质：引用的本质在C++内部就是指针常量；
int& ref=a;--------->int* const ref=&a;
编译器内部会做解引用的操作；
------------------------------------常量引用-------------------------
作用：常量引用主要用来修饰形参，放置误操作；
引用必须引一块合法的内存空间；const int & ref=10;
void Show(const int & val)//函数体内不能修改该参数了
{
cout<<"val="<<val<<endl;
}
int main()
{
int a=10;
Show(a);
return 0;
}
